# 3. 삽입 정렬

# 핵심 아이디어 : 각 숫자를 적절한 위치에 삽입한다. ( 적절한 위치 : 주어진 조건을 충족하는 위치로 보낸다)

# 정렬 시 각 숫자를 적절한 위치에 삽입하는 방법이다.
# 선택/버블 정렬은 무조건 위치를 바꾸는 방식이었던 반면에, 삽입 정렬은 필요시에만 위치를 바꾼다.

# 정렬시, 앞에 있는 원소들이 이미 정렬되어 있다고 가정한다.
# 따라서 기준점 왼쪽의 원소는 정렬을 가정하기 때문에, 기준점이 왼쪽보다 크다면 바로 break

#  ======> 버블, 선택 정렬은 만약 이미 정렬되있는 상태라 하더라도 일단 반복문을 수행한다

# 오름 차순 정렬시 : 오름 차순 정렬? 작은 값 부터 차례 대로 => 주어진 범위를 탐색 하는 "i"를 왼쪽의 정렬된 범위를 돌며 대소를 비교 하다가 더 작은 값이 나오면 멈춤 => 반복
# 탐색하는 요소만 보는 이유 = 탐색하려는 요소의 범위를 제외한 부분은 이미 정렬되었다고 가정하기 때문에
#                       현재 탐색하는 요소를 이미 정렬된 부분과 대소만 비교하다가 조건 충족하면 중지 후 다음 요소로 넘어간다.

# 따라서 이미 거의 정렬되어 있는 리스트를 정렬할 때 버블, 선택 정렬보다 훨씬 빠르게 정렬

# 삽입 정렬 구현 (오름 차순으로 구현한다)왼쪽 시작점보다

def f_insertion(arr):
    for i in range(len(arr)):
        # 정렬을 실시할 해당 요소의 인덱스를 j라고 설정한다
        j = i
        #  j를 1씩 빼가면서 (정렬되었다고 가정하는 현재 요소i 기준왼쪽의 범위를 돌면서) 왼쪽 값이 오른쪽값보다 크다면 자리를 바꿔주면서 진행한다.
        while j > 0 and arr[j] < arr[j - 1]:
            temp = arr[j]
            arr[j] = arr[j - 1]
            arr[j - 1] = temp
            j -= 1
        print(i)
    # 최종적으로 나온 arr를 리턴한다.
    return arr
# def f_insertion(arr):
#     for i in range(len(arr)):
#         while i > 0 and arr[i] < arr[i - 1]:
#             temp = arr[i]
#             arr[i] = arr[i - 1]
#             arr[i - 1] = temp
#             i -= 1
#         print(i)
    # 최종적으로 나온 arr를 리턴한다.
    return arr


# arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9]
# arr = [11, 12, 15, 16, 13, 18, 14, 17, 20, 19]
# arr = [16, 7, 12, 11, 8, 10, 9, 15, 13, 14]
arr = [10, 17, 0, 0, 3, 6, 18, 2]

print(f_insertion(arr))
