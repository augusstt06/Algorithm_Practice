# 4. 퀵 정렬

# 핵심 아이디어 : 특정 값을 기준으로 큰 숫자와 작은 숫자로 나눈다.

# 앞서 공부한 선택, 버블, 삽입 알고리즘과 다르게 O(N * logN)의 시간 복잡도를 가진다 ==> 훨씬 빠름 // 히지만 이 시간 복잡도를 보장 할 순 없음
# 대표적인 분할 정복 알고리즘 (이게 뭔지 찾아보기)

# 다른 정렬과 다르게 피벗 (Pivot) 이라는 기준 값이 존재 한다. (위 아이디어에서 말한 기준이란 이 피벗을 의미한다.)
# 이 피벗을 기준으로 오른쪽 왼쪽으로 나눈다. (일반적으로 가장 앞에 있는 요소로 설정한다)

# 피벗을 기준으로 한번 정렬이 될때마다 다시 새로운 피벗 값을 정해줘야 하기 때문에 재귀함수를 이용한다.

# 기본 동작 구조
# 1) 피벗 값을 설정 한다. -> 기본적인 데이터 탐색을 왼쪽 -> 오른쪽, 오른쪽 -> 왼쪽 이렇게 두 가지의 탐색 방법을 사용 한다.
# 2) 왼 -> 오 탐색 시, 피벗 값보다 큰 값을 탐색 한다. (i) /// 오 -> 왼 탐색 시 피벗 값보다 작은 값을 탐색 한다. (j)
# 3) i,j의 탐색 값을 모두 찾았다면, 찾은 i와 j의 위치를 바꿔준다.
# 4) 다시 3)을 시행한다.
# 5) 만약 i,j의 탐색 결과, i의 인덱스 값이 j의 인덱스 값 보다 크다면 (엇갈림),i와 현재 피벗 값의 위치를 바꿔준다. /// 이때 데이터를 한번 분할 하는 것
#       ==> 이때 바뀐 피벗 값의 왼쪽은 모두 피벗 값보다 작고, 오른쪽은 모두 피벗 값보다 크다
# 6) 나뉜 왼쪽의 범위, 오른쪽의 범위에서 각각 새로운 피벗 값을 설정하여 2) ~ 5)를 수행한다. ==> 이 과정에서 재귀함수가 사용된다.

# 퀵 정렬 구현 (오름차순)

def f_quick(arr, start, end):

    # 원소가 한 개인 경우 바로 종료
    if start >= end:
        return

    # key = 피벗 값
    key = start
    # i = 왼 -> 오 로 탐색 하는 기준점 (왼쪽 출발 지점)
    i = start + 1
    # j = 오 -> 왼 으로 탐색하는 기준점 (오른쪽 출발 지점)
    j = end

    # i와 j가 서로 엇갈릴 때 까지 반복 한다. ==> 엇갈리면 이 while문을 탈출한다. ( 5)의 조건 )
    while i <= j:
        # key 값 보다 큰 i값을 만날 때 까지 /// i <= end 의 조건은 큰 값을 탐색하다 시작했던 요소를 넘어서 탐색하면 안되기 때문에 설정

        while i <= end and arr[i] <= arr[key]:
            # 오른쪽으로 이동하며 탐색한다
            i += 1
        # key 값 보다 작은 j값을 만날 때 까지 /// j > start 의 조건은 작은 값을 탐색하다 시작했던 요소를 넘어서 탐색하면 안되기 떄문에 설정

        while j > start and arr[j] >= arr[key]:
            # 왼쪽으로 이동하며 탐색한다.
            j -= 1

        # 만약 지금 엇갈린 상태 라면 밑의 조건문을 실행하고 가장 상위의 while 문을 탈출한다.
        if i > j:
            temp = arr[j]
            arr[j] = arr[key]
            arr[key] = temp
        else:
            temp = arr[i]
            arr[i] = arr[j]
            arr[j] = temp
    f_quick(arr, start, j - 1)
    f_quick(arr, j + 1, end)

    return arr


arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9]
# arr = [2, 10, 5, 9, 8, 7, 4, 6, 3, 11]


print(f_quick(arr, 0, len(arr) - 1))
