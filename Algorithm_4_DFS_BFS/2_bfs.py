# BFS : 너비 우선 탐색
# 시작점의 인접한 정점을 모두 방문 한 후, 방문점을 시작점으로 다시 인접점 방문

# 기본 진행
# 1. 최초 시작 노드 방문 ==> 방문 처리, 큐에 삽입
# 2. 큐에서 출력(제거) 후 모든 인접 노드 방문 처리, 큐에 삽입
# 3. 1~2번을 계속 반복하며 큐 안의 요소가 없을 때까지 반복

# 큐에서 출력(제거)하며 해당 노드에서 탐색을 완료 했다는 뜻

# 큐에 삽입 : 해당 노드를 방문 처리 // 해당 노드가 인접 되어 있다는 것을 알림
# 큐에서 출력 : 해당 노드에서 인접 노드 탐색 완료
# 따라서 큐에서 요소를 출력 했을때 요소가 남아 있지 않다는 것은 해당 노드에서 탐색했을때 남아 있는 인접 노드가 없다는 것
# ===> 탐색 종료


# 주로 최단경로를 찾는데 주로 사용된다.

# 예시

from collections import deque


def bfs(graph, start, visited):
    # 최초 시작 노드를 큐에 입력.
    queue = deque([start])
    # 최초 시작 노드 방문 처리
    visited[start] = True

    # 위의 2개의 과정을 큐가 빌 때 까지 반복 해야 하므로 반복문을 사용한다.
    while queue:

        # 큐 안에서 요소 하나 출력 == 현재 노드 위치
        n = queue.popleft()
        print(n, end=' ')

        # 현재 노드 위치(출력한 요소)의 인접 노드 확인
        for i in graph[n]:
            # 만약 현재 노드 위치(출력한 요소)의 인접 노드 i를 방문 하지 않았다면
            if not visited[i]:
                # 인접 노드 i를 큐에 입력 하고
                queue.append(i)
                # 인접 노드 i를 방문 처리 한다.
                visited[i] = True
        # if문(방문 하지 않은 인접 노드)의 조건을 더 이상 충족 하지 않을 때 까지 반복


graph = [
    # 0번 노드는 비운다
    [],
    # 리스트 원소의 인덱스 노드와 연결된 리스트 원소의 노드를 뜻한다
    # 인덱스 = 1, 1번 노드와 연결된 원소들, 2,3,8번 노드를 뜻함
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 노드의 방문 정보
# 총 노드의 갯수 + 0번 인덱스 = 8 + 1
visited = [False] * (8+1)

bfs(graph, 1, visited)
